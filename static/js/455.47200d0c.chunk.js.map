{"version":3,"file":"static/js/455.47200d0c.chunk.js","mappings":"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","sources":["components/utils/WorldUtils.js","components/gadgets/MapGadget.js"],"sourcesContent":["export default class WorldUtils {\n\n    // calculate geo-paths between two locations using great circle formula\n    static calcPaths(origin, dest) {\n        let interval = 200;\n        let paths = [[]];\n        let pathID = 0;\n        let distance = this.calcDistance(origin, dest);\n        if (distance <= interval) {\n            paths[pathID].push({ x: origin.lon, y: origin.lat });\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\n        } else {\n            let current = origin;\n            let previous = origin;\n\n            for (let dist = interval; dist <= distance; dist += interval) {\n                previous = current;\n                paths[pathID].push({ x: current.lon, y: current.lat });\n\n                let bearing = this.calcBearing(current, dest);\n                current = this.calcDestination(current, bearing, interval);\n                // ensure geo-path wrap around the world through the new date-line\n                if (previous.lon > 150 && current.lon < -150) {\n                    paths[pathID].push({ x: 180, y: current.lat });\n                    paths.push([]);\n                    pathID++;\n                    current = { lon: -180, lat: current.lat };\n                } else if (previous.lon < -150 && current.lon > 150) {\n                    paths[pathID].push({ x: -180, y: current.lat });\n                    paths.push([]);\n                    pathID++;\n                    current = { lon: 180, lat: current.lat };\n                }\n            }\n            paths[pathID].push({ x: dest.lon, y: dest.lat });\n        }\n        return paths;\n    }\n\n    // calculate bearing angle between two locations\n    static calcBearing(origin, dest) {\n        origin = this.toRadianLocation(origin);\n        dest = this.toRadianLocation(dest);\n        let range = (dest.lon - origin.lon);\n        let y = Math.sin(range) * Math.cos(dest.lat);\n        let x = Math.cos(origin.lat) * Math.sin(dest.lat) -\n                Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range);\n        let angle = Math.atan2(y, x);\n        return this.toDegreesNormalized(angle);\n    }\n\n    // calculate destination for origin location and travel distance\n    static calcDestination(origin, bearing, distance) {\n        let radius = 6371.0;\n        origin = this.toRadianLocation(origin);\n        bearing = this.toRadians(bearing);\n        distance = distance / radius; // angular distance in radians\n\n        let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) +\n                       Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing));\n        let x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat);\n        let y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat);\n        let lon = origin.lon + Math.atan2(x, y);\n        // normalize lon to coordinate between -180º and +180º\n        lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI;\n\n        lon = this.toDegrees(lon);\n        lat = this.toDegrees(lat);\n\n        return { lon: lon, lat: lat };\n    }\n\n    // calculate distance between two locations\n    static calcDistance(origin, dest) {\n        origin = this.toRadianLocation(origin);\n        dest = this.toRadianLocation(dest);\n        let sinProd = Math.sin(origin.lat) * Math.sin(dest.lat);\n        let cosProd = Math.cos(origin.lat) * Math.cos(dest.lat);\n        let lonDelta = (dest.lon - origin.lon);\n\n        let angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta));\n        let distance = angle * 6371.0;\n        return distance; // in km\n    }\n\n    static toRadianLocation(geoPoint) {\n        let x = this.toRadians(geoPoint.lon);\n        let y = this.toRadians(geoPoint.lat);\n        return { lon: x, lat: y };\n    }\n\n    static toRadians(degrees) {\n        return degrees * Math.PI / 180;\n    }\n\n    static toDegrees(radians) {\n        return (radians * 180.0 / Math.PI);\n    }\n\n    static toDegreesNormalized(radians) {\n        let degrees = this.toDegrees(radians);\n        degrees = (degrees + 360) % 360;\n        return degrees;\n    }\n\n    // converts latitude coordinate to a string\n    static toStringLat(latitude) {\n        let str = Math.abs(latitude).toFixed(1) + \"°\";\n        return latitude > 0 ? str + \"N\" : str + \"S\";\n    }\n\n    // converts longitude coordinate to a string\n    static toStringLon(coordinate) {\n        let val = Math.abs(coordinate);\n        let str = val < 100 ? val.toFixed(1) : val.toFixed(0);\n        return coordinate > 0 ? str + \"°E\" : str + \"°W\";\n    }\n\n    static toStringAbbr(value) {\n        if (value > 1000000000000) {\n            return (value / 1000000000000).toFixed(1) + \" T\"\n        } else if (value > 1000000000) {\n            return (value / 1000000000).toFixed(1) + \" B\"\n        } else if (value > 1000000) {\n            return (value / 1000000).toFixed(1) + \" M\"\n        } else if (value > 1000) {\n            return (value / 1000).toFixed(1) + \" K\"\n        }\n        return value.toFixed(0);\n    }\n\n    static getLongitude(location) {\n        if (location.x) return location.x;\n        if (location.lon) return location.lon;\n        if (location.longitude) return location.longitude;\n        return Number.NaN;\n    }\n\n    static getLatitude(location) {\n        if (location.y) return location.y;\n        if (location.lat) return location.lat;\n        if (location.latitude) return location.latitude;\n        return Number.NaN;\n    }\n\n    static getBounds(locations) {\n        let minLat = 90;\n        let maxLat = -90;\n        let minLon = 180;\n        let maxLon = -180;\n\n        for (const location of locations) {\n            const crrLon = this.getLongitude(location);\n            if (!Number.isNaN(crrLon)) {\n                minLon = Math.min(minLon, crrLon);\n                maxLon = Math.max(maxLon, crrLon);\n            }\n\n            const crrLat = this.getLatitude(location);\n            if (!Number.isNaN(crrLat)) {\n                minLat = Math.min(minLat, crrLat);\n                maxLat = Math.max(maxLat, crrLat);\n            }\n        }\n\n        const geoBounds = {\n            left: minLon,\n            top: minLat,\n            width: Math.abs(maxLon - minLon),\n            height: Math.abs(maxLat - minLat)\n        };\n        return geoBounds;\n    }\n\n    static getNightShapes() {\n        let nightShape = [];\n\n        let line = [];\n\n        for (let lon = -180; lon <= 180; lon += 1) {\n            let x = lon;\n            let y = 75 * Math.cos(lon * Math.PI / 180);\n            line.push({ x: x, y: y });\n        }\n\n        let coordinateLine = { points: [line] };\n        nightShape.push(coordinateLine);\n\n        return nightShape;\n    }\n}\n","import React, { useEffect, useState } from 'react';\nimport {\n  IgrGeographicMap,\n  IgrGeographicSymbolSeries,\n  IgrGeographicMapModule,\n} from 'igniteui-react-maps';\nimport { IgrDataChartInteractivityModule } from 'igniteui-react-charts';\nimport WorldUtils from '../utils/WorldUtils';\n\nIgrGeographicMapModule.register();\nIgrDataChartInteractivityModule.register();\n\nconst MapGadget = ({ gadget, isFullscreen }) => {\n  const [geoMap, setGeoMap] = useState(null);\n  const [data, setData] = useState([]); // State to hold fetched data\n  const [loading, setLoading] = useState(true); // State to manage loading\n\n  // Fetch data when component mounts\n  useEffect(() => {\n    fetch(process.env.PUBLIC_URL+gadget.datasource)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        return response.json();\n      })\n      .then((jsonData) => {\n        setData(jsonData);\n        setLoading(false); // Data fetched, stop loading\n      })\n      .catch((error) => {\n        console.error('Error fetching data:', error);\n        setLoading(false); // Error occurred, stop loading\n      });\n  }, []);\n\n  // Function to handle map resizing and redrawing the map\n  const handleResize = () => {\n    if (geoMap && data.length > 0) {\n      const geoBounds = WorldUtils.getBounds(data);\n      if (geoBounds) {\n        geoMap.zoomToGeographic(geoBounds);\n      }\n    }\n  };\n\n  // Adjust map when isFullscreen changes or data loads\n  useEffect(() => {\n    handleResize();\n  }, [isFullscreen, geoMap, data]);\n\n  // Adjust map when window resizes\n  useEffect(() => {\n    const handleWindowResize = () => {\n      handleResize();\n    };\n\n    window.addEventListener('resize', handleWindowResize);\n    return () => {\n      window.removeEventListener('resize', handleWindowResize);\n    };\n  }, [geoMap, data]);\n\n  // Show a loading indicator while data is being fetched\n  if (loading) {\n    return <div>Loading map data...</div>;\n  }\n\n  return (\n    <div\n      style={{\n        width: '100%',\n        height: isFullscreen ? '100vh' : gadget.height,\n        minHeight: gadget.height,\n      }}\n    >\n      <IgrGeographicMap\n        width=\"100%\"\n        height=\"100%\"\n        zoomable={true}\n        isHorizontalZoomEnabled={true}\n        isVerticalZoomEnabled={true}\n        panModifier=\"None\"\n        ref={setGeoMap}\n        defaultInteraction=\"DragPan\"\n      >\n        <IgrGeographicSymbolSeries\n          dataSource={data}\n          latitudeMemberPath=\"latitude\"\n          longitudeMemberPath=\"longitude\"\n          markerType=\"Circle\"\n          markerBrush=\"yellow\"\n          markerOutline=\"black\"\n          showTooltip={true}\n          name=\"wellSeries\"\n          tooltipTemplate={(context) => {\n            if (!context.item) {\n              console.error(\n                'No item found in context for tooltip rendering'\n              );\n              return `<div>No data available</div>`;\n            }\n            return `<div>\n              Well: ${context.item.name} <br/>\n              Type: ${context.item.type} <br/>\n              Lat: ${context.item.latitude} <br/>\n              Lng: ${context.item.longitude}\n            </div>`;\n          }}\n        />\n      </IgrGeographicMap>\n    </div>\n  );\n};\n\nexport default MapGadget;\n"],"names":["WorldUtils","calcPaths","origin","dest","interval","paths","pathID","distance","this","calcDistance","push","x","lon","y","lat","current","previous","dist","bearing","calcBearing","calcDestination","toRadianLocation","range","Math","sin","cos","angle","atan2","toDegreesNormalized","toRadians","asin","PI","toDegrees","sinProd","cosProd","lonDelta","acos","geoPoint","degrees","radians","toStringLat","latitude","str","abs","toFixed","toStringLon","coordinate","val","toStringAbbr","value","getLongitude","location","longitude","Number","NaN","getLatitude","getBounds","locations","minLat","maxLat","minLon","maxLon","crrLon","isNaN","min","max","crrLat","left","top","width","height","getNightShapes","nightShape","line","coordinateLine","points","IgrGeographicMapModule","register","IgrDataChartInteractivityModule","_ref","gadget","isFullscreen","geoMap","setGeoMap","useState","data","setData","loading","setLoading","useEffect","fetch","process","datasource","then","response","ok","Error","status","json","jsonData","catch","error","console","handleResize","length","geoBounds","zoomToGeographic","handleWindowResize","window","addEventListener","removeEventListener","_jsx","children","style","minHeight","IgrGeographicMap","zoomable","isHorizontalZoomEnabled","isVerticalZoomEnabled","panModifier","ref","defaultInteraction","IgrGeographicSymbolSeries","dataSource","latitudeMemberPath","longitudeMemberPath","markerType","markerBrush","markerOutline","showTooltip","name","tooltipTemplate","context","item","type"],"sourceRoot":""}